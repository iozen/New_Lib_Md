
**Вихід пустити в нікуди**

2>/dev/null


./error.sh 2> capture.txt
./error.sh 1> capture.txt 2> error.txt



                   Что такое stdin, stdout и stderr в Linux?

   Spread the love

   stdin, stdout и stderr — это три потока данных, которые создаются при запуске команды Linux. Вы можете использовать их, чтобы
   определить, передаются ли ваши скрипты по конвейеру или перенаправляются. Мы покажем вам, как это сделать.

   Оглавление

     • Потоки объединяются в две точки
     • Стандартные потоки Linux
     • Потоки обрабатываются как файлы
     • Реакция на каналы и перенаправления
     • Перенаправление stdout и stderr
     • Перенаправление как stdout, так и stderr
     • Перенаправление stdout и stderr в один файл
     • Обнаружение перенаправления в сценарии
     • Потоки сознания

          • Share this post!

Потоки объединяются в две точки

   Как только вы начнете знакомиться с Linux и Unix-подобными операционными системами, вы встретите термины stdin, stdout и
   stederr. Эти три стандартных потока которые устанавливаются при выполнении команды Linux. В вычислениях поток — это то, что
   может передавать данные. В случае этих потоков эти данные являются текстовыми.

   У потоков данных, как и у водных потоков, есть два конца. У них есть источник и отток. Какую бы команду Linux вы ни
   использовали, она обеспечивает один конец каждого потока. Другой конец определяется оболочкой, запустившей команду. Этот конец
   будет подключен к окну терминала, подключен к каналу или перенаправлен к файлу или другой команде в соответствии с командной
   строкой, запустившей команду.

Стандартные потоки Linux

   В Linux стандартным входным потоком является stdin. Это принимает текст в качестве ввода. Текстовый вывод команды в оболочку
   доставляется через поток stdout (стандартный вывод). Сообщения об ошибках от команды отправляются через поток stderr
   (стандартная ошибка).

   Итак, вы можете видеть, что есть два выходных потока, stdout и stderr, и один входной поток, stdin. Поскольку сообщения об
   ошибках и нормальный вывод имеют свой собственный канал для передачи их в окно терминала, они могут обрабатываться независимо
   друг от друга.

Потоки обрабатываются как файлы

   Потоки в Linux — как и почти все остальное — обрабатываются как файлы. Вы можете читать текст из файла и записывать текст в
   файл. Оба эти действия включают поток данных. Так что концепция обработки потока данных как файла не так уж и сложна.

   Каждому файлу, связанному с процессом, присваивается уникальный номер для его идентификации. Это известно как файловый
   дескриптор. Всякий раз, когда требуется выполнить действие с файлом, дескриптор файла используется для идентификации файла.

   Эти значения всегда используются для stdin, stdout и stderr:

   0: стандартный ввод
   1: стандартный вывод
   2: stderr

Реакция на каналы и перенаправления

   Чтобы облегчить кому-то знакомство с предметом, распространенной техникой является преподавание упрощенной версии темы.
   Например, в грамматике нам говорят, что правило — «I до E, кроме C.» Но на самом деле там больше исключений из этого правила чем
   есть случаи, которые ему подчиняются.

   Аналогичным образом, говоря о stdin, stdout и stderr, удобно использовать общепринятую аксиому о том, что процесс не знает и не
   заботится о том, где завершаются его три стандартных потока. Должен ли процесс заботиться о том, идет ли его вывод на терминал
   или перенаправляется в файл? Может ли он даже сказать, идет ли его ввод с клавиатуры или передается в него из другого процесса?

     Как установить IDE PhpStorm в Linux

   На самом деле процесс знает — или, по крайней мере, может узнать, если решит проверить, — и может соответствующим образом
   изменить свое поведение, если автор программного обеспечения решил добавить эту функциональность.

   Мы можем очень легко увидеть это изменение в поведении. Попробуйте эти две команды:

 ls

 ls | cat

   ls вывод в окне терминала

   Команда ls ведет себя иначе, если ее вывод (stdout) передается другой команде. Это ls, который переключается на вывод в один
   столбец, это не преобразование, выполняемое cat. И ls делает то же самое, если его вывод перенаправляется:

 ls > capture.txt

   ls> capture.txt в окне терминала ”width =” 646 ″ height = ”57 ″ onload =” pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon
   (this); » onerror = ”this.onerror = null; pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this);”> </p> <pre> cat
   capture.txt </pre> <p> <img loading =

Перенаправление stdout и stderr

   Есть преимущество в том, что сообщения об ошибках доставляются выделенным потоком. Это означает, что мы можем перенаправить
   вывод команды (stdout) в файл и по-прежнему видеть любые сообщения об ошибках (stderr) в окне терминала. При необходимости вы
   можете реагировать на ошибки по мере их возникновения. Он также предотвращает заражение сообщений об ошибках файла, в который
   был перенаправлен стандартный вывод.

   Введите следующий текст в редактор и сохраните его в файл с именем error.sh.

 #!/bin/bash

 echo "About to try to access a file that doesn't exist"
 cat bad-filename.txt

   Сделайте скрипт исполняемым с помощью этой команды:

 chmod +x error.sh

   Первая строка скрипта выводит текст в окно терминала через поток stdout. Вторая строка пытается получить доступ к
   несуществующему файлу. Это приведет к появлению сообщения об ошибке, которое доставляется через stderr.

   Запустите сценарий с помощью этой команды:

 ./error.sh

   ./error.sh в окне терминала

   Мы видим, что оба потока вывода, stdout и stderr, были отображены в окнах терминала.

   вывод из сценария error.sh в окне терминала

   Попробуем перенаправить вывод в файл:

 ./error.sh > capture.txt

   ./error.sh> capture.txt в окне терминала ”width =” 646 ″ height = ”57 ″ onload =”
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this); » onerror = ”this.onerror = null;
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this);”> </p> <p> Сообщение об ошибке, которое доставляется через stderr,
   по-прежнему отправляется в окно терминала. Мы можем проверить содержимое файла, чтобы увидеть, попал ли вывод stdout в файл.
   </p> <pre> cat capture.txt </pre> <p> <img loading =

   Вывод из стандартного ввода был перенаправлен в файл, как и ожидалось.

   содержимое файла capture.txt в окне терминала

   Символ перенаправления> по умолчанию работает с stdout. Вы можете использовать один из числовых дескрипторов файла, чтобы
   указать, какой стандартный выходной поток вы хотите перенаправить.

   Чтобы явно перенаправить stdout, используйте эту инструкцию перенаправления:

 1>

   Чтобы явно перенаправить stderr, используйте эту инструкцию перенаправления:

 2>

   Давайте попробуем снова провести наш тест, и на этот раз мы будем использовать 2>:

 ./error.sh 2> capture.txt

   ./error.sh 2> capture.txt в окне терминала ”width =” 646 ″ height = ”57 ″ onload =”
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this); » onerror = ”this.onerror = null;
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this);”> </p> <p> Сообщение об ошибке перенаправляется, а эхо-сообщение
   stdout отправляется в окно терминала: </p> <div style=
     Как играть в Left 4 Dead 2 на Linux

   Как и ожидалось, сообщение stderr находится в файле capture.txt.

   содержимое файла capture.txt в окне терминала

Перенаправление как stdout, так и stderr

   Конечно, если мы можем перенаправить либо stdout, либо stderr в файл независимо друг от друга, мы должны иметь возможность
   перенаправить их обоих одновременно в два разных файла?

   Да мы можем. Эта команда направит stdout в файл с именем capture.txt и stderr в файл с именем error.txt.

 ./error.sh 1> capture.txt 2> error.txt

   ./error.sh 1> capture.txt 2> error.txt в окне терминала ”width =” 646 ″ height = ”57 ″ onload =”
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this); » onerror = ”this.onerror = null;
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this);”> </p> <p> Поскольку оба потока вывода — стандартный вывод и
   стандартная ошибка — перенаправляются в файлы, видимый вывод в окно терминала. Мы вернулись в командную строку, как будто ничего
   не произошло. </p> <p> <img loading =

   Проверим содержимое каждого файла:

 cat capture.txt

 cat error.txt

   содержимое capture.txt и error.txt в окне терминала

Перенаправление stdout и stderr в один файл

   Это замечательно, у нас есть каждый из стандартных выходных потоков, идущих в отдельный выделенный файл. Единственная другая
   комбинация, которую мы можем сделать, — это отправить stdout и stderr в один и тот же файл.

   Мы можем добиться этого с помощью следующей команды:

 ./error.sh > capture.txt 2>&1

   Давайте разберемся с этим.

   ./error.sh: Запускает файл сценария error.sh.
   > capture.txt: перенаправляет поток стандартного вывода в файл capture.txt. > — это сокращение от 1>.
   2> & 1: здесь используется инструкция перенаправления &>. Эта инструкция позволяет вам указать оболочке, чтобы один поток попал
   в то же место назначения, что и другой поток. В данном случае мы говорим «перенаправить поток 2, stderr, в то же место
   назначения, куда перенаправляется поток 1, stdout».

   ./error.sh> capture.txt 2 &> 1 в окне терминала ”width =” 646 ″ height = ”57 ″ onload =”
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this); » onerror = ”this.onerror = null;
   pagespeed.lazyLoadImages.loadIfVisibleAndMaybeBeacon (this);”> </p> <p> Нет видимого вывода. Это обнадеживает. </p> <p> <img
   loading =

   Давайте проверим файл capture.txt и посмотрим, что в нем.

 cat capture.txt

   содержимое файла capture.txt в окне терминала

   И потоки stdout, и потоки stderr были перенаправлены в один файл назначения.

   Чтобы вывод потока перенаправлялся и незаметно отбрасывался, направьте вывод в / dev / null.

Обнаружение перенаправления в сценарии

   Мы обсудили, как команда может определить, перенаправляется ли какой-либо из потоков, и может соответствующим образом изменить
   свое поведение. Можем ли мы сделать это в наших собственных сценариях? Да мы можем. И это очень простой метод для понимания и
   применения.

   Введите следующий текст в редактор и сохраните его как input.sh.

 #!/bin/bash

 if [ -t 0 ]; then

   echo stdin coming from keyboard

 else

   echo stdin coming from a pipe or a file

 fi

   Используйте следующую команду, чтобы сделать его исполняемым:

 chmod +x input.sh

   Умная часть — это тест в квадратных скобках. Параметр -t (терминал) возвращает истину (0), если файл, связанный с файловым
   дескриптором заканчивается в окне терминала. Мы использовали файловый дескриптор 0 в качестве аргумента теста, который
   представляет стандартный ввод.

   Если stdin подключен к окну терминала, тест подтвердится. Если stdin подключен к файлу или каналу, тест завершится неудачно.

     Как установить Signal Privacy Messenger в Linux

   Мы можем использовать любой удобный текстовый файл для генерации входных данных в скрипт. Здесь мы используем файл dummy.txt.

 ./input.sh

 ./input.sh <dummy.txt в окне терминала


 The output shows that the script recognizes that the input isn’t coming from a keyboard, it is coming from a file. If you chose to, you could vary your script’s behavior accordingly.


 вывод скрипта в окне терминала


 Это было с перенаправлением файлов, давайте попробуем с конвейером.


 кот dummy.txt |  ./input.sh


 кот dummy.txt | ./input.sh в окне терминала


 Сценарий распознает, что его ввод передается по конвейеру.  Или, точнее, он еще раз распознает, что поток stdin не подключен к окну терминала.


 вывод скрипта в окно терминала


 Запустим скрипт без каналов и перенаправлений.


 ./input.sh


 ./input.sh в окне терминала


 Поток stdin подключен к окну терминала, и сценарий сообщает об этом соответственно.


 Чтобы проверить то же самое с выходным потоком, нам нужен новый скрипт.  Введите в редактор следующее и сохраните как output.sh.


 #!/bin/bash

 if [ -t 1 ]; then

 echo stdout is going to the terminal window

 else

 echo stdout is being redirected or piped

 fi


 Используйте следующую команду, чтобы сделать его исполняемым:


 chmod +x input.sh


 Единственное существенное изменение в этом скрипте - это тест в квадратных скобках.  Мы используем цифру 1 для обозначения файлового дескриптора для stdout.


 Давай попробуем.  Мы пропустим вывод через cat.


 ./output | cat


 ./output | кот в окне терминала


 Сценарий распознает, что его вывод не идет напрямую в окно терминала.


 вывод скрипта в окне терминала


 Мы также можем протестировать скрипт, перенаправив вывод в файл.


 ./output.sh > capture.txt


 ./output.sh> capture.txt в окне терминала


 В окне терминала нет вывода, мы молча возвращаемся в командную строку.  Как и следовало ожидать.


 вывод скрипта в окне терминала


 Мы можем заглянуть внутрь файла capture.txt, чтобы увидеть, что было захвачено.  Для этого используйте следующую команду.


 cat capture.sh


 cat capture.sh в окне терминала


 Опять же, простой тест в нашем скрипте обнаруживает, что поток stdout не отправляется непосредственно в окно терминала.


 Если мы запустим скрипт без каналов или перенаправлений, он должен обнаружить, что стандартный вывод доставляется непосредственно в окно терминала.


 ./output.sh


 ./output.sh в окне терминала


 И это именно то, что мы видим.


 вывод скрипта в окне терминала


 Потоки сознания


 Знание того, как определить, подключены ли ваши скрипты к окну терминала, каналу или перенаправляются, позволяет вам соответствующим образом корректировать их поведение.


 Вывод журнала и диагностики может быть более или менее подробным, в зависимости от того, идет ли он на экран или в файл.  Сообщения об ошибках можно записывать в файл, отличный от обычного вывода программы.


 Как это обычно бывает, чем больше знаний, тем больше возможностей.
