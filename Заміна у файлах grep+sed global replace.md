sed -i 's/foo/bar/g' *
Вхождения "foo" будут заменены на "bar".

sed -i '.bak' 's/foo/bar/g' *

Аналогично ответу Каспара, но с флагом g для замены всех вхождений в строку.
find ./ -type f -exec sed -i 's/string1/string2/g' {} \;

Для глобального нечувствительного к регистру:
find ./ -type f -exec sed -i 's/string1/string2/gI' {} \;


@kev's ответ хорош, но влияет только на файлы в ближайшем каталоге. В приведенном ниже примере grep используется для рекурсивного поиска файлов. Это работает для меня каждый раз.

grep -rli 'old-word' * | xargs -i@ sed -i 's/old-word/new-word/g' @


Тут можна використовувати **** замість символів

sed -i 's/old-word/new-word/g' $(grep -rl 'old-word')


!!! Експерементально 

Тут можна використовувати **** замість символів тоді флаг -E

sed -i -E 's/old-****/new-word/g' $(grep -rl 'old-***')


grep -r : --рекурсивное, рекурсивное чтение всех файлов в каждом каталоге
. grep-l : --print-with-matches, печатает имя каждого файла, имеющего совпадение, вместо печати совпадающих строк
. grep-i : -- игнорировать-случай .

размер : превратить STDIN на аргументы, за этот ответ
. xargs -i@ ~command содержит @~ : заполнитель для аргумента, который будет использоваться в определенной позиции в ~command~, знак @ является заполнителем, который может быть заменен любой строкой.

sed-i: редактирование файлов на месте , без резервных копий
. sed s/regexp/replacement/: замените строку, соответствующую регулярному выражению, заменой
. sed s/regexp/replacement/ g : global, сделайте замену для каждого матча, а не только для первого матча.